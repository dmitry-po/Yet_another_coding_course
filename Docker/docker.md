# Docker
## Основные термины
**Container (контейнер)** - изолированная среда с минимально необходимым набором компонентов, выполняющая заданный в образе функционал (иными словами, выполняющийся образ);  
**Image (образ)** - образ базовой операционной системы, код приложения и зависимые библиотеки, скомпонованные в виде единой сущности, на основе которой можно создать контейнер (иными словами, результат сборки Dockerfile);  
**Dockerfile** - набор инструкций для сборки образа;  

## Настройка контейнера
1. Написать исполняемый код;
2. Настроить файл-конфигуратор образа Dockerfile;
3. Создать образ командой `docker build user/image_name .`;
4. Запустить образ командой `docker run user/image_name`;
5. ...;
6. Profit.
> [**Dockerfile**] ---*build*--> [**Image**] ---*run*--> [**Container**]

## Dockerfile
В файлах Dockerfile содержатся инструкции по созданию образа. Инструкции, при сборке образа, обрабатываются сверху вниз. Пример файла:
``` docker
# Example of Dockerfile
FROM python:3
LABEL maintainer="https://github.com/dmitry-po/"
WORKDIR /usr/src/app
COPY requirements.txt ./
RUN pip install --no-cache-dir -r requirements.txt
VOLUME /logs
COPY . .
EXPOSE 5000
CMD ["python", "./app.py"]
```
Все инструкции, которые используются в Dockerfile делятся на основные (формируют слои) и дополнительные (описывают метаданные). В примере выше первый слой - это базовый образ python, следующий - надстройка в виде сторонних библиотек, последний - изменяемый слой непосредственно с данными и исполняемым кодом. В целях экономии ресурсов, Docker по умолчанию пытается использовать кэширование. Например, при сборке данного образа Docker будет проверять, не создавались ли другие образы на основе python - если да, то возмет данные из кэша. И так далее с каждым слоем.
### Основные инструкции:
* **FROM** инициирует базовый (родительский) образ. Помимо *python* также часто используются, например, *nginx:alpine*, *ubuntu:18.04*. В одном Dockerfile может быть исопльзовано несколько инструкций FROM для описания [многоступенчатой сборки образа](https://docs.docker.com/develop/develop-images/multistage-build/) - это полезно, например, для уменьшения конечного размера образа;
* **COPY** копирует данные из указанной папки хоста в указанную папку образа;
* **ADD** копирует файлы и папки (в том числе с удаленного источника), а также распаковывает локальные *.tar файлы;
* **RUN** выполняет заданную команду. В примере выше это установка дополнительных библиотек, также часто используется запись *"RUN apt-get update && apt-get upgrade"* при работе с контейнерами на базе Linux. Выполнение команды создает новый слой.

### Дополнительные инструкции:
* **WORKDIR** устанавливает рабочую директорию для следующей команды (если директории нет, она будет создана);
* **ENV** задает переменные окружения контейнера;
* **CMD** описывает команду с переменными, которую необходимо выполнить после запуска контейнера. Может быть использована только один раз в Dockerfile (если команд несколько, выполняется только последняя);
* **ENTRYPOINT** аналогично CMD задает начальную команду с аргументами, которая выполняется при запуске контейнера. В примере выше можно заменить последнюю строку на *ENTRYPOINT ["python", "./app.py"]*. В отличие от CMD, при запуске контейнера с параметрами командной строки, параметры инструкции ENTRYPOINT не перезаписываются, а дополняются. Общие рекомендации:
  * В Dockerfile должна быть хотя бы одна инструкция CMD или ENTRYPOINT;
  * Если при каждом запуске контейнера необходимо выполнять одну и ту же команду - используется ENTRYPOINT;
  * Если контейнер будет использоваться в качестве приложения - используется ENTRYPOINT;
  * Если при запуске контейнера ему необходимо будет передавать аргументы, которые должны менять аргументы, описанные в Dockerfile - используется CMD.
* **EXPOSE** указывает на необходимость открыть порт. Это только указание, фактическое открытие порта осуществляется при запуске контейнера (параметр *-p*);
* **VOLUME** создает точку монтирования для работы с постоянным хранилищем;
* **LABEL** описывает метаданные о контейнере.

## Полезные команды
`docker build [OPTIONS] PATH | URL | -` - формирование образа из Dockerfile:
* -f, --file \<file> - указание пути к файлу Dockerfile (по умолчанию файл ищется в текущей директории);
* --no-cache - отключает функционал поиска кэша для сборки образа;
* -t, --tag \<name>\<:tag> - присвоение имени и тега (по умолчанию присваивается тег latest).

`docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH` - копирование данных из контейнера. Без использования выделенного хранилища (Volume), данные в контейнере хранятся до его полного удаления;

`docker images [OPTIONS]` - отображение всех доступных образов:
 * -a, --all - указывает на необходимость вывода всех образов, включая завершенные;
 * -f, --filter \<filter expression> - осуществляет поиск по заданному выражению *filter expression* (например, "status=exited");
 * -q, --quiet - указывает на необходимость вывода только id образов.

`docker port CONTAINER` - выводит список открытых портов контейнера *CONTAINER*.

`docker ps [OPTIONS]` - отображение контейнеров (параметры аналогичны команде images).

`docker rm CONTAINER [CONTAINER...]` - удаление контейнера (или нескольких через пробел).

`docker rmi IMAGE [IMAGE...]` - удаление образов.

`docker run [OPTIONS] IMAGE [COMMAND] [ARG...]` - запуск контейнера с образом *IMAGE* с последующим исполнением команды *COMMAND* с аргументами *ARG*. Часто используемые параметры:
 * -d, --detach - открепляет контейнер от консоли;
 * -i, --interactive - запускает контейнер в итеративном режиме (оставляет поток STDIN открытым);  
 * --name \<name> - позволяет задать имя контейнера;
 * -P, --publish-all - делает все порты открытыми и случайными;
 * -p, --publish \<host-port>:\<docker-port> - открывает указанный порт (например, 8888:80 будет перенаправлять данные с порта 80 контейнера на порт 8888 хоста);
 * --restart - определяет политику перезапуска контейнера: *no* (не перезапускать; значение по умолчанию), *on-failure* (перезапускать только в случае аварийной остановки), *always* (перезапускать всегда; если контейнер был остановлен вручную - перезапуск будет выполнен вручную или автоматически при перезапуске демона Docker), *unless-stopped* (аналогично *always*, за тем исключением, что автоматический перезапуск при перезапуске демона Docker выполнен не будет);
 * --rm - удаляет контейнер при завершении;
 * -t, --tty - выделяет псевдо-терминал для работы  с STDIN STDOUT (комбинацию флагов -i -t можно заменить -it).

 `docker stop CONTAINER` - останавливает контейнер c указанным идентификатором.  

## Работа с данными
По умолчанию все данные, которые создаются и обрабатываются в контейнере, остаются в контейнере, непосредственно в слое с исполняемым приложением. Жизненый цикл данных в таком случае тесно связан с жизненным циклом контейнера: данные могут пережить остановку контейнера, но не его удаление. Также при подобном подходе ограничен доступ к этим данным из-вне контейнера.  
Для организации долговременного хранения, а также совместного доступа к информации применяются способы *bind mount*, *volumes*, *tmpfs* (для Linux) и *named pipes* (для Windows).
![Ways of storing data with Docker](https://docs.docker.com/storage/images/types-of-mounts.png)

1.
2.
3. При использовании *tmpfs* данные будут храниться в специально отведенной области оперативной памяти хоста, что позволяет достичь более высокой скорости чтения/записи. Подходит только для временного хранения, так как удаление происходит не только вместе с контейнером, но и в момент его остановки (что может быть удобно и полезно при работе с чувствительной информацией). Такое хранилище может одновременно работать только с 1 контейнером. Для использования данного типа нужно использовать флаг --tmpfs 
4.

**Volumes (тома)** - механизм постоянного хранения данных.

## .dockerignore
При необходимости исключить часть файлов из сборки образа, в корне директории создается файл с расширением **.dockerignore**, в котором прописываются правила исключения файлов (аналогично .gitignore) в виде имен или шаблонов. Таким образом удобно исключать временные файл и/или уменьшать размер образа. Например:
```
__pycache__
some_temp_data/img
useless_code.js
*.code-workspace
```

## Источники
1. [Docker docs](https://docs.docker.com/get-started/):
2. [Полное практическое руководство по Docker: с нуля до кластера на AWS](https://habr.com/ru/post/310460/);
3. [Настройка Dockerfile для Python](https://hub.docker.com/_/python/);
4. [Цикл статей "Изучаем Docker"](https://habr.com/ru/company/ruvds/blog/438796/);
5. [Хранение данных в Docker](https://slurm.io/tpost/i5ikrm9fj1-hranenie-dannih-v-docker).